# Linux内核概述


## 1 用户接口
用户与系统之间通过程序进行交互。


## 2 用户标识符
用户以唯一的账号登录，关联一个唯一的UID。内核用UID验证用户的文件访问权限。
root用户没有权限限制，UID为0。

用户也是一个或多个组的成员，每个组都有唯一的GID。当一个用户创建后，就会以自动成为与用户名同名的组的成员。

一个文件或程序总是与权限关联，这权限授予用户或组。任何特定的用户都可以决定谁可以访问他的文件，谁不可以访问，
于是，一个文件总是与某个特定的UID或GID相关联。


## 3 文件和文件系统
文件系统提供了存储和组织数据的一种方法。Linux把文件的概念描述成独立于设备的字节序列。


### 3.1 安装文件系统
文件系统的安装用 mount 系统调用，卸载用 umount。
/etc/mtab 所有安装的文件系统及与之关联的安装点和安装时的选项。
/etc/fstab 所有文件系统及其属性。

### 3.2 文件访问权限
访问权适用于三类不同的用户：用户本身，与用户同属相同组的用户，所有用户。
这三种类型的用户授予不用的访问权限：读、写和执行。
如 rwxr-xr-x

### 3.3 文件模式
除了访问权，文件还有另外三种模式：sticky、suid和sgid。

- sticky
启用了sticky位的文件或目录在mode字段的最后一个字符为 t (如 -rwx----t)。
当一个目录上启用了sticky位时，它防止对目录具有写权限的用户删除或更名其中的文件。
chmod o+t test 设置sticky位。

    sticky 位禁止用户从公共目录（如 /tmp）中删除其他用户的文件

    drwxrwxrwt  12 root root   340  4月 16 19:08 tmp

- suid
如果文件设置了suid位，那么用户访问位上的可执行位'x'就变成's'(如 -rwsr-xr-x)。
当用户执行了一个可执行文件时，执行进程就与调用这个文件的用户关联。如果可执行位
设置了suid位，那么进程就关联文件拥有者的UID，因而就可以使用拥有者的所有访问权。
suid对目录无效。
chmod u+s file 设置suid位。

    passwd命令
 
	-rwsr-xr-x 1 root root    55448 12月 31 21:11 passwd

- sgid
如果文件设置了sgid，那么用户组访问位上的可执行位'x'就变成's'(如 -rwxr-sr-x)。
sgid位类似于suid位，不过它用于组。
如果目录设置了sgid，那么在该目录内创建的文件，不属于创建者所属的组，而是属于该目录所属的组。
这个功能通常用于文件共享。
chmod g+s test 设置sgid位


### 3.4 文件元数据
文件元数据就是对文件进行描述的所有信息，但不包含文件的内容。
元数据包含文件类型、文件大小、文件所有者UID、访问权等。
某些文件类型（设备、管道、套接字）只有元数据，不包含任何数据。
文件的所有元数据都存放在inode(index node)中。

### 3.5 文件类型

- 普通文件
    模式字段第一个字符为'-'
- 目录文件
    模式字段第一个字符为'd'
- 块设备文件
    模式字段第一个字符为'b'
    这些文件实际上表示硬件设备，其I/O是以2的幂次方数据块大小进行传送的。
    可以通过文件系统中的/dev目录访问这些设备。
- 字符设备文件
    模式字段第一个字符为'c'
    这些文件也表示硬件，但数据是为字节流传送的。
- 链接文件
    模式字段第一个字符为'l'
    链接就是指定文件的指针。这种文件类型允许某个特定的文件有多个引用，
    但实际上在文件系统中只有一份文件的副本，也只有一份数据。
    有两种类型的链接：硬链接和软链接。
    硬链接的文件必须是同一种文件系统，不能链接到目录，不能链接不存在的文件。
    链接文件的访问权就是它指向的文件的权限。
- 命名管道文件
    模式字段的第一个字符为'p'
- 套接字文件
    模式字段的第一个字符为's'

### 3.6 文件系统的类型
Linux文件系统为各种文件系统类型共存提供了一种接口。
文件系统包括网络文件系统（NFS）、磁盘文件系统（ext4)、
某些特殊的文件系统(/proc)。

## 4 进程

### 4.1 进程的创建和控制
一个进程是通过另一个进程创建的，这是通过 fork() 系统调用实现的。
所有进程都有一个父进程，init进程除外。
所有进程都是第一个进程init的后代，init进程在系统启动时就产生的。

当子进程被创建时，父进程可能想知道子进程什么时候完成，wait() 系统调用用来暂停父进程，直到子进程退出。

一个进程也可能用另一个进程来替代自己，通过调用 exec() 类系统调用实现。

### 4.2 进程 ID
每个进程都有一个唯一的标识符 PID。PID是一个非负整数，当进程创建时，以递增的顺序给其分配 PID。
有两个特殊的进程：进程0 和 进程1。
进程0负责系统的初始化，并创建进程1，进程1也叫 init进程。

getpid() 系统调用获得当前进程ID。
getppid() 系统调用获得父进程ID。

### 4.3 进程组
进程可以是进程组中的一名成员，一组中的所有成员具有相同的GID。
如果进程的PID和组GID相同，则该进程是组长。
getpgid() 系统调用获得进程的组ID。
setpgid() 系统调用设置其组ID。

### 4.4 进程描述符
每个进程都有一个进程描述符，存放着进程的所有信息。包含：进程状态、PID、启动时所用的命令等。
可以通过调用 ps 命令来显示。

	USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
	root       630  1.3  1.3 545708 107060 tty1    Ssl+ 10:43   9:55 /usr/lib/Xorg -nolisten tcp -auth /var/run/sddm/{546db264-98d0-4e
	linux    12836  0.0  0.0  11808  5564 pts/1    Ss   18:53   0:00 /bin/bash
	linux    16309  0.0  0.0  15868  3220 pts/1    R+   22:52   0:00 ps -au

STAT列表示进程的状态，S表示睡眠进程，R表示正在运行或可运行的进程。

### 4.5 进程优先级
可以调用 nice() 系统调用设置进程的优先级。
这个调用表示一个进程对另一个进程友好的程序，意味着进程愿意让出多少优先级。
nice值越大，表明该进程越愿意转让运行权。

## 5 系统调用
系统调用是用户程序与内核通信的主要机制。

## 6 Linux设备驱动程序
设备驱动程序是内核与硬盘、内存、声卡、网上以及其它输入输出设备进行交互的接口。
设备驱动被封装在一个模块中。Linux尽管是一个单模块内核，但达到了高度的模块化，
每个设备驱动都可以动态的安装。

